---
layout: post
title: 'Advisory: Adobe Flash Player and AIR AVM2 intf_count Integer Overflow'
date: '2009-08-02T04:30:00.002+03:00'
author: Roee Hay
tags: 
modified_time: '2009-08-05T11:03:09.905+03:00'
---

<h4 class="smallcap">Background</h4>
ActionScript code is compiled into ActionScript Byte Code segments, loaded by AVM2 (ActionScript Virtual Machine 2).      <br />These segments are described by the abcFile structure: </font></p>
{% highlight C %}
struct abcFile    
{       
   u16 minor_version;
   u16 major_version;
   cpool_info constant_pool;
   u30 method_count;
   method_info method[method_count];
   u30 metadata_count;
   metadata_info metadata[metadata_count];
   u30 class_count;
   instance_info instance[class_count];
   class_info class[class_count];
   u30 script_count;
   script_info script[script_count];
   u30 method_body_count;
   method_body_info method_body[method_body_count];
}    
{% endhighlight %}
   <br />The value of <em><strong>class_count</strong></em> element is the number of entries in the <em><strong>instance</strong></em> and <em><strong>class</strong></em> arrays. Each instance entry is a variable length <em><strong>instance_info</strong></em> structure which specifies the characteristics of object instances created by a particular class:<br><br>
{% highlight C %}
struct instance_info 
{       
   u30 name      
   u30 super_name       
   u8 flags      
   u30 protectedNs     
   u30 intrf_count      
   u30 interface[intrf_count]      
   u30 iinit    
   u30 trait_count      
   traits_info trait[trait_count]
}
 {% endhighlight %}<p align="justify">The value of the <strong><em>intrf_count</em></strong> field is the number of entries in the interface array. The interface array contains indices into the multiname array of the constant pool; the referenced names specify the interfaces implemented by this class. </p> <h4>Vulnerability </h4>An integer overflow exists in the AVM2 abcFile parser code which handles the <strong><em>intrf_count</em></strong> value of the instance_info structure. </p>  <p>When <strong>intrf_count</strong> is larger than 0x10000000, it is nullified due to an integer overflow. This results in an out of bounds pointer dereference. The out of bounds object contains arbitrary values (in the context of the code which handles the interfaces count element) which are manipulated in a way so that an arbitrary memory overwrite with an attacker supplied destination and value is possible. </p>The following is a detailed run trace which explains the vulnerability. Irrelevant instructions are omitted. Flash10b.ocx is assumed to be loaded at VA 10000000h. <br>Let &lt;intrf_count&gt; be 0x10000000 <blockquote>   <p><font color="#800000" size="2" face="Consolas">.text:10206B03&#160; mov&#160; edi, [esp+50h+var_2C]        <br /></font><font size="2" face="Consolas"><font color="#008000">; EDI=&lt;intrf_count&gt;=0x10000000          <br /></font><font color="#800000">.text:10206B14&#160; lea&#160; edx, [edi+edi]          <br /></font><font color="#008000">; EDX=&lt;intrf_count*2&gt;=0x20000000, m</font></font><font size="2" face="Consolas"><font color="#008000">ay not overflow (verified elsewhere)</font>&#160; <br /><font color="#800000">.text:10206B1B&#160; call&#160; sub_101EAC30&#160; <br />.text:101EAC45&#160; call&#160; sub_101EAB90</font>&#160; <br /><font color="#800000">.text:101EAB98&#160; call&#160; sub_101D1FF0          <br /></font></font><font color="#008000"><font size="2" face="Consolas">; this method calculates the nearest p</font><font size="2" face="Consolas">ower of 2 for &lt;intrf_count*2&gt;&#160; (i.e: </font></font><font size="2" face="Consolas"><font color="#008000">stays 0x20000000)&#160; <br /></font><font color="#800000">.text:101EABA0&#160; add&#160; eax, eax          <br /></font><font color="#008000">; doubles that value (i.e: EAX=0x40000000)&#160; <br /></font><font color="#800000">.text:101EABCC&#160; lea&#160; ecx, ds:0[eax*4]          <br /></font><font color="#008000">; multiplies it by 4 (i.e: ECX=0x00000000) <strong>=&gt;OVERFLOW&lt;=</strong>           <br /></font></font><font size="2" face="Consolas"><font color="#800000">.text:101EABDA&#160; call&#160; sub_10224C62&#160; <br />.text:10224C62&#160; jmp&#160;&#160; sub_10224363&#160; <br />.text:10224363&#160; mov&#160;&#160; edx, [esp+arg_0]           <br /></font><font color="#800000"><font color="#008000">; arg_0 is the overflown value (i.e: EDX=00000000) </font>          <br />.text:10224367&#160; lea&#160;&#160;&#160;&#160; eax, [edx+7]           <br /></font><font color="#800000">.text:10224376&#160; and&#160;&#160;&#160;&#160; eax, 0FFFFFFF8h </font></font><font size="2" face="Consolas"><font color="#008000">; EAX=00000000
&#160; <br /></font><font color="#800000">.text:1022437A&#160; mov&#160;&#160;&#160;&#160; esi, eax </font>&#160;&#160;&#160;&#160;&#160;&#160; <font color="#008000">; ESI=00000000&#160; <br /></font><font color="#800000">.text:102243A4&#160; mov&#160;&#160;&#160;&#160; ecx, esi&#160;&#160; </font>&#160;&#160;&#160;&#160; <font color="#008000">; ECX=00000000&#160; <br /></font><font color="#800000">.text:102243A9&#160; mov&#160;&#160;&#160;&#160; eax, [eax+ecx*4-4]          <br /></font><font color="#008000">; the overflown value is used as an index into pointer table, starting at EAX.          <br />; since we can cause ECX to become 0x0000000, we may select an out of bounds           <br />; pointer (eax-4). Tests show that it always contains a valid pointer to some           <br />; object, with arbitrary values. i.e: EAX=&amp;OutOfBoundsObject           <br /></font><font color="#800000">.text:102243AD&#160; mov&#160;&#160;&#160;&#160; ecx, eax</font>&#160;&#160;&#160;&#160;&#160;&#160;&#160; <font color="#008000">; ECX=&amp;OutOfBoundsObject&#160; <br /></font><font color="#800000">.text:102243C8&#160; call&#160;&#160;&#160; sub_10226D4D          <br />.text:10226D53&#160; mov&#160;&#160;&#160;&#160; ebx, ecx&#160; </font>&#160;&#160;&#160;&#160;&#160; <font color="#008000">; EBX=&amp;OutOfBoundsObject          <br /></font><font color="#800000">.text:10226D6C&#160; mov&#160;&#160;&#160;&#160; esi, [ebx+8] </font>&#160;&#160; <br /><font color="#008000">; ESI=&amp;ArbitraryObjectA (usually: 0x55555555) </font>        <br /><font color="#800000">.text:10226D76&#160; test&#160;&#160;&#160; byte ptr [esi+2Ah], 1          <br /></font><font color="#008000">; &lt;PathConditionA &gt;- must pass this in order to continue          <br /></font><font color="#800000">.text:10226D7A&#160; jz&#160;&#160;&#160;&#160;&#160; short loc_10226DA5 </font>        <br /><font color="#800000">.text:10226D7C&#160; mov&#160;&#160;&#160;&#160; eax, [ebx+38h]          <br /></font><font color="#008000">; EAX=&amp;ArbitraryObjectB, (usually 0x55555557)&#160; <br /></font><font color="#800000">.text:10226D7F&#160; cmp&#160;&#160;&#160;&#160; byte ptr [eax+33Ch], 0          <br /></font><font color="#008000">; &lt;PathConditionB&gt; - must pass this in order to continue </font>        <br /><font color="#800000">.text:10226D86&#160; mov&#160;&#160;&#160;&#160; ecx, ebx </font><font color="#008000">; ECX=&amp;OutOfBoundsObject          <br /></font><font color="#800000">.text:10226D88&#160; jnz&#160;&#160;&#160;&#160; short loc_10226D9D </font>        <br /><font color="#800000">.text:10226D8A&#160; push&#160;&#160;&#160; esi          <br />.text:10226D8B&#160; call&#160;&#160;&#160; sub_10226CAF</font>         <br /><font color="#800000">.text:10226CB0&#160; mov&#160;&#160;&#160;&#160; esi, [esp+4+arg_0]          <br /></font><font color="#008000">; ESI=&amp;ArbitraryObjectA, (usually 0x55555555)          <br /></font><font color="#800000">.text:10226CB5&#160; push&#160;&#160;&#160; esi </font>        <br /><font color="#800000">.text:10226CB6&#160; mov&#160;&#160;&#160;&#160; edi, ecx </font><font color="#008000">; EDI=&amp;OutOfBoundsObject          <br /></font><font color="#800000">.text:10226CB8&#160; call&#160;&#160;&#160; sub_102266CA </font>        <br /><font color="#800000">.text:102266CA&#160; mov&#160;&#160;&#160;&#160; eax, [esp+arg_0]          <br /></font><font color="#008000">; EAX=ESI=&amp;ArbitraryObjectA (usually 0x55555555) </font>        <br /><font color="#800000">.text:102266DB&#160; mov&#160;&#160;&#160;&#160; ecx, [eax+1Ch]          <br /></font><font color="#008000">; ECX=arbitrary value&#160; - usually *(0x55555571)          <br /></font><font color="#800000">.text:102266CE&#160; mov&#160;&#160;&#160;&#160; edx, [eax+20h]          <br /></font><font color="#008000">; EDX=arbitrary value&#160; - usually *(0x55555575) </font>        <br /><font color="#800000">.text:102266DE&#160; mov&#160;&#160;&#160;&#160; [ecx+20h], edx;          <br /></font><font color="#008000">; jackpot - a write of an arbitrary DWORD to an arbitrary VA </font></font></p>    <p>&#160;</p> </blockquote>  <p>The following is an illustration of the pointer table and the out of bounds pointer which may be dereferenced: </p>  <blockquote>   <p><font face="Consolas">&#160;&#160;&#160; addr&#160;&#160;&#160;&#160;&#160; val        <br />&#160;&#160;&#160; 0017487C&#160; 00E82000 &lt;- EAX-4 (ECX=0)         <br />&#160;&#160;&#160; 00174880&#160; 001681C8 &lt;- EAX&#160;&#160; (ECX=1)         <br />&#160;&#160;&#160; 00174884&#160; 00174AC8         <br />&#160;&#160;&#160; 00174888&#160; 00174BD0         <br />&#160;&#160;&#160; 0017488C&#160; 00174CD8         <br />&#160;&#160;&#160; 00174890&#160; 00174DE0         <br />&#160;&#160;&#160; 00174894&#160; 00174EE8         <br />&#160;&#160;&#160; 00174898&#160; 00174FF0         <br />&#160;&#160;&#160; 0017489C&#160; 001750F8         <br />&#160;&#160;&#160; 001748A0&#160; 00175200         <br />&#160;&#160;&#160; 001748A4&#160; 00175308         <br />&#160;&#160;&#160; 001748A8&#160; 00175410         <br />&#160;&#160;&#160; 001748AC&#160; 00175518         <br />&#160;&#160;&#160; 001748B0&#160; 00175620         <br />&#160;&#160;&#160; 001748B4&#160; 00175728         <br />&#160;&#160;&#160; 001748B8&#160; 00175830         <br />&#160;&#160;&#160; 001748BC&#160; 00175938         <br />&#160;&#160;&#160; 001748C0&#160; 00175A40         <br />&#160;&#160;&#160; 001748C4&#160; 00175B48         <br />&#160;&#160;&#160; 001748C8&#160; 00175C50         <br />&#160;&#160;&#160; 001748CC&#160; 00175D58</font> </p> </blockquote>  The following is a memory dump of the out of bounds object: <blockquote>   <p><font size="2" face="Consolas">&#160;&#160;&#160; 00E82000&#160; 44 51 55 55 55 45 55 75 55 55 55 55 55 55 55 55&#160;&#160; <br />&#160;&#160;&#160; 00E82010&#160; 55 55 55 55 55 55 55 54 55 55 55 55 01 00 00 00&#160;&#160; <br />&#160;&#160;&#160; 00E82020&#160; 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 50&#160;&#160; <br />&#160;&#160;&#160; 00E82030&#160; 55 55 55 55 D5 55 55 55 57 55 55 55 55 55 55 55&#160;&#160; <br />&#160;&#160;&#160; 00E82040&#160; D5 5A 55 55 54 55 55 55 55 55 55 55 75 B5 56 55&#160;&#160; <br />&#160;&#160;&#160; 00E82050&#160; 55 55 55 55 15 55 55 D5 55 55 AD 55 77 D5 55 55&#160;&#160; <br />&#160;&#160;&#160; 00E82060&#160; 55 55 55 55 D5 D5 BA 56 55 55 55 55 55 55 6B 55&#160;&#160; <br />&#160;&#160;&#160; 00E82070&#160; B5 56 55 55 57 55 55 01 00 00 00 00 00 00 00 00&#160;&#160; <br />&#160;&#160;&#160; 00E82080&#160; 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00&#160;&#160; <br />&#160;&#160;&#160; 00E82090&#160; 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00&#160;&#160; <br />&#160;&#160;&#160; 00E820A0&#160; 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00&#160;&#160; <br />&#160;&#160;&#160; 00E820B0&#160; 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00&#160;&#160; <br />&#160;&#160;&#160; 00E820C0&#160; 00 00 00 00 00 00 00 00 00 00
&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; </font></p> </blockquote> To make things more clear: <br><br>Let <strong>'ArbitraryObjectA'</strong> be pointed by (&amp;<strong>OutOfBoundsObject</strong>+0x8)     <br />Let <strong>'ArbitraryObjectB'</strong> be pointed by (&amp;<strong>OutOfBoundsObject</strong>+0x38) </p>  <p>In order to reach the arbitrary overwrite, there are three conditions </p>  <p>1)&#160; <strong>intrf_count</strong> &gt;= 0x10000000 // in order to overflow     <br />2)&#160; <strong>PathConditionA</strong>: ((char *)ArbitraryObjectA)[0x2e]&#160; == 1&#160; //&#160; .text:10226D76     <br />3)&#160; <strong>PathConditionB</strong>: ((char *)ArbitraryObjectB)[0x33c] == 0&#160; //&#160; .text:10226D7F <br><br>Given the conditions are passed, a memory DWORD overwrite of arbitrary target and value occurs: 
{% highlight C %}
*(DWORD *)((*(DWORD *)(ArbitraryObjectA+0x1c))+0x20) = *(DWORD *)(ArbitraryObjectA+0x20)
{% endhighlight %}
<h4>Exploitation</h4>
Since the out of bounds object contains arbitrary values, the attacker may spray the heap so he/she would have control over <em>ArbitraryObjectA</em> and <em>ArbitraryObjectB</em> (they would be located at addresses which contain data controlled by the attacker). This may allow him/her to pass all aforementioned conditions and also control the value which is written&#160; in the arbitrary memory MOV and the target of it. Achieving this may allow him the execute arbitrary code.     <br />    <br />During the research of this vulnerability I’ve managed to create a functional exploit (demo: <a href="http://www.youtube.com/watch?v=wJb6a-J3i4c">http://www.youtube.com/watch?v=wJb6a-J3i4c</a>).</p> It should also be denoted that the vulnerable code is wrapped by an SEH handler which doesn't crash the application on Access Violation. This means that the exploitation process may try different base addresses and offsets in case of a failure.   <p><strong><u><font size="2">Attack vector</font>         <br /></u></strong>    <br />Lure the victim to open a malicious SWF file</p><h4>Impact</h4>Remote Code Execution<h4>Test Environment</h4>1. Adobe Flash Player 10.0.22.87<br>2. Windows XP SP3. <h4>Identifiers</h4>1<em>. CVE-ID</em>: <a href="http://web.nvd.nist.gov/view/vuln/detail?vulnId=CVE-2009-1869">CVE-2009-1869</a>     <br />2. BID: <a href="http://www.securityfocus.com/bid/35907">35907</a><h4>Remediation</h4>New versions of Adobe Flash Player (10.0.32.18) and AIR (1.5.2) have been released in order to address this vulnerability. <h4>References</h4><ol>   <li><a href="(http://www.adobe.com/devnet/actionscript/articles/avm2overview.pdf">&quot;ActionScript Virtual Machine 2 (AVM2) Overview&quot;</a>, Adobe Systems, Inc. </li>    <li><a href="http://www.adobe.com/support/security/bulletins/apsb09-10.html">Adobe’s advisory</a> </li> </ol>
